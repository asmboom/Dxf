<# // Copyright (c) IxMilia.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information. #>
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ output extension=".cs" #>
<#
var xml = XDocument.Load(this.Host.ResolvePath(@"TableSpec.xml")).Root;
var xmlns = "http://IxMilia.com/Dxf/TableSpec";
var tables = xml.Elements(XName.Get("Table", xmlns));
#>
// Copyright (c) IxMilia.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

// The contents of this file are automatically generated by a tool, and should not be directly modified.

using System.Linq;
using System.Collections.Generic;
using IxMilia.Dxf.Sections;
using IxMilia.Dxf.Tables;

namespace IxMilia.Dxf.Tables
{
<#

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                tables
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

foreach (var table in tables)
{
    var tableItem = Name(table.Element(XName.Get("TableItem", xmlns)));
#>

    public partial class Dxf<#= Type(table) #>Table : DxfTable
    {
        internal override DxfTableType TableType { get { return DxfTableType.<#= Type(table) #>; } }
        public List<<#= tableItem #>> Items { get; private set; }

        protected override IEnumerable<DxfSymbolTableFlags> GetSymbolItems()
        {
            return Items;
        }

        public Dxf<#= Type(table) #>Table()
        {
            Items = new List<<#= tableItem #>>();
        }

        internal static DxfTable ReadFromBuffer(DxfCodePairBufferReader buffer)
        {
            var table = new Dxf<#= Type(table) #>Table();
            while (buffer.ItemsRemain)
            {
                var pair = buffer.Peek();
                buffer.Advance();
                if (DxfTablesSection.IsTableEnd(pair))
                {
                    break;
                }

                if (pair.Code == 0 && pair.StringValue == DxfTable.<#= TypeStringVariable(table) #>)
                {
                    var item = <#= tableItem #>.FromBuffer(buffer);
                    table.Items.Add(item);
                }
            }

            return table;
        }
    }
<#
}
#>
}

namespace IxMilia.Dxf
{
<#

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           table items
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

foreach (var table in tables)
{
    var tableItem = table.Element(XName.Get("TableItem", xmlns));
    var properties = tableItem.Elements(XName.Get("Property", xmlns));
#>

    public partial class <#= Name(tableItem) #> : DxfSymbolTableFlags
    {
        internal const string AcDbText = "<#= ClassName(tableItem) #>";

        protected override DxfTableType TableType { get { return DxfTableType.<#= Type(table) #>; } }
<#
    var backingFields = properties.Where(p => SetConverter(p) != null);
    if (backingFields.Any())
    {
#>

        // backing fields
<#
        foreach (var field in backingFields)
        {
            var fieldType = Type(field);
            if (AllowMultiples(field))
            {
                fieldType = string.Format("List<{0}>", fieldType);
            }
#>
        private <#= fieldType #> <#= BackingFieldName(Name(field)) #>;
<#
        }
    }
#>

        // properties
<#
    var seenProperties = new HashSet<string>();
    foreach (var property in properties)
    {
        var name = Name(property);
        if (seenProperties.Contains(name))
        {
            this.Warning("Duplicate property found: " + name);
        }
        else
        {
            seenProperties.Add(name);
            var propertyType = Type(property);
            if (AllowMultiples(property))
            {
                propertyType = string.Format("List<{0}>", propertyType);
            }

            var getset = string.Format("{{ get; {0}set; }}", SetterAccessibility(property));
            var setConverter = SetConverter(property);
            if (setConverter != null)
            {
                getset = string.Format("{{ get {{ return {0}; }} {1}set {{ {0} = {2}(value); }} }}", BackingFieldName(name), SetterAccessibility(property), setConverter);
            }
#>
        <#= Accessibility(property) #> <#= propertyType #> <#= name #> <#= getset #>
<#
        } // else
    } // foreach (var property in properties)

#>

        public DxfXData XData { get; set; }

        public <#= Name(tableItem) #>()
            : base()
        {
<#
    foreach (var property in properties)
    {
        var defaultValue = DefaultValue(property);
        if (AllowMultiples(property))
            defaultValue = string.Format("new List<{0}>()", Type(property));
#>
            <#= Name(property) #> = <#= defaultValue #>;
<#
    } // foreach (var property in properties)

#>
        }

        internal override void AddValuePairs(List<DxfCodePair> pairs, DxfAcadVersion version, bool outputHandles)
        {
            if (version >= DxfAcadVersion.R13)
            {
                pairs.Add(new DxfCodePair(100, AcDbText));
            }

            pairs.Add(new DxfCodePair(2, Name));
<#
    if (HasFlags(tableItem))
    {
#>
            pairs.Add(new DxfCodePair(70, (short)StandardFlags));
<#
    } // has flags
    foreach (var property in properties)
    {
        var disableWritingDefault = DisableWritingDefault(property);
        var writeCondition = WriteCondition(property);
        var minVersion = MinVersion(property);
        var maxVersion = MaxVersion(property);
        var hasPredicate = disableWritingDefault || writeCondition != null || minVersion != null || maxVersion != null;
        var indent = hasPredicate ? "    " : "";
        string predicate = null;
        if (hasPredicate)
        {
            var parts = new List<string>();
            if (disableWritingDefault) parts.Add(string.Format("{0} != {1}", Name(property), DefaultValue(property)));
            if (writeCondition != null) parts.Add(writeCondition);
            if ((minVersion != null || maxVersion != null) && minVersion == maxVersion)
            {
                parts.Add("version == DxfAcadVersion." + minVersion);
            }
            else
            {
                if (minVersion != null) parts.Add("version >= DxfAcadVersion." + minVersion);
                if (maxVersion != null) parts.Add("version <= DxfAcadVersion." + maxVersion);
            }
            predicate = string.Join(" && ", parts);
        }

        if (AllowMultiples(property))
        {
            if (hasPredicate)
            {
#>
            if (<#= predicate #>)
            {
<#
            } // if
#>
            <#= indent #>pairs.AddRange(<#= Name(property) #>.Select(value => new DxfCodePair(<#= Code(property) #>, value)));
<#
            if (hasPredicate)
            {
#>
            }

<#
            } // if
        }
        else
        {
            var codeOverrides = CodeOverrides(property);
            if (Code(property) < 0 && codeOverrides != null)
            {
                char prop = 'X';
                for (int i = 0; i < codeOverrides.Length; i++, prop++)
                {
                    if (hasPredicate)
                    {
#>
            if (<#= predicate #>)
            {
<#
                    } // if
#>
            <#= indent #>pairs.Add(new DxfCodePair(<#= codeOverrides[i] #>, <#= Name(property) #>?.<#= prop #> ?? 0.0));
<#
                    if (hasPredicate)
                    {
#>
            }

<#
                    } // if
                } // for
            }
            else
            {
                if (hasPredicate)
                {
#>
            if (<#= predicate #>)
            {
<#
                } // if
#>
            <#= indent #>pairs.Add(new DxfCodePair(<#= Code(property) #>, <#= WriteConverter(property) #>(<#= Name(property) #>)));
<#
                if (hasPredicate)
                {
#>
            }

<#
                } // if
            }
        }
    } // foreach (var property in properties)
#>
            if (XData != null)
            {
                XData.AddValuePairs(pairs, version, outputHandles);
            }
        }

        internal static <#= Name(tableItem) #> FromBuffer(DxfCodePairBufferReader buffer)
        {
            var item = new <#= Name(tableItem) #>();
            while (buffer.ItemsRemain)
            {
                var pair = buffer.Peek();
                if (pair.Code == 0)
                {
                    break;
                }

                buffer.Advance();
                switch (pair.Code)
                {
<#
    if (HasFlags(tableItem))
    {
#>
                    case 70:
                        item.StandardFlags = (int)pair.ShortValue;
                        break;
<#
    } // has flags

#>
                    case DxfCodePairGroup.GroupCodeNumber:
                        var groupName = DxfCodePairGroup.GetGroupName(pair.StringValue);
                        item.ExtensionDataGroups.Add(DxfCodePairGroup.FromBuffer(buffer, groupName));
                        break;
<#

    foreach (var property in properties)
    {
        var codeOverrides = CodeOverrides(property);
        if (Code(property) < 0 && codeOverrides != null)
        {
            char prop = 'X';
            for (int i = 0; i < codeOverrides.Length; i++, prop++)
            {
                var codeType = DxfCodePair.ExpectedType(codeOverrides[i]);
                var codeTypeValue = TypeToString(codeType);
#>
                    case <#= codeOverrides[i] #>:
                        item.<#= Name(property) #>.<#= prop #> = <#= ReadConverter(property) #>(pair.<#= codeTypeValue #>);
                        break;
<#
            }
        }
        else
        {
            var code = Code(property);
            var codeType = DxfCodePair.ExpectedType(code);
            var codeTypeValue = TypeToString(codeType);
            if (AllowMultiples(property))
            {
#>
                    case <#= Code(property) #>:
                        item.<#= Name(property) #>.Add(<#= ReadConverter(property) #>(pair.<#= codeTypeValue #>));
                        break;
<#
            }
            else
            {
#>
                    case <#= Code(property) #>:
                        item.<#= Name(property) #> = <#= ReadConverter(property) #>(pair.<#= codeTypeValue #>);
                        break;
<#
            }
        }
    } // foreach (var property in properties)
#>
                    case (int)DxfXDataType.ApplicationName:
                        item.XData = DxfXData.FromBuffer(buffer, pair.StringValue);
                        break;
                    default:
                        item.TrySetPair(pair);
                        break;
                }
            }

            return item;
        }
<#
#>
    }
<#
} // foreach (var table in tables)
#>
}
<#@ include file="$(ProjectDir)\DxfCommon.t4" #>
